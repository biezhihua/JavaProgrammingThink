

## 定义任务

Thread.yield()的调用是对线程调度器(Java线程机制的一部分，可以将CPU从一个县城转移给另一个线程)

它在声明：我已经执行完声明周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机．


## 使用Executor 执行器

shutdown()防止新任务被提交给Executor

## 从任务中产生返回值

Runnable是执行工作的独立任务，但是没有返回值．如果希望获取返回值，那么应该使用Callable接口．必须使用ExecutorService.submit();

submit()方法会产生Future对象，isDone()查询Future是否完成.也可以不用isDone()进行检查就直接调用get()，这种情况下get()将阻塞方法直到获取
该结果，直至结果准备就绪

## 优先级

线程的优先级将该县城的重要性传递给调度器．优先级较低的线程仅仅是执行的频率较低．

绝大多数情况，所有线程都应该以默认优先级运行，试图操纵线程优先级通常是一种错误．

## 让步

## 后台 daemon 线程

是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分．
当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程．

必须在线程启动之前调用setDaemon()方法，才能把其设置为后台线程．

可以通过isDaemon()来确定线程是否是一个后台线程，如果是一个后台线程，呢么它创建的任何线程都被自动设置成后台线程．

后台线程在不执行finally子句的情况下就会终止其run()方法．因为，当一个非后台线程终止时，后台线程会＂突然＂终止.
因此,一旦main()退出,JVM就会立即关闭所有的后台线程.

## 编码的变体


## 捕获异常

# 共享受限资源

volatile是原子性的,即诸如赋值和返回值这样的简单操作在发生时没有中断的可能.

在java中,递增过程中任务可能会被线程机制挂起---也就是说,在java中,递增不是原子性操作.

## 解决共享资源竞争

你永远不知道一个线程何时在运行.

对于并发工作,需要某种方式来防止两个任务访问相同的资源,至少在关键阶段不能出现这种情况.

基本上所有的并发模式在解决线程冲突的问题时,都是采用序列化访问共享资源的方案.

这意味着在给定的时刻只允许一个任务访问共享资源.这通常是在代码前面加上一条锁语句,使得在一段时间内只有一个任务运行这段代码.

因为锁语句产生了一种互相排斥的效果,所以这种机制常常称为互斥量. mutex.

synchronized防止资源冲突提供了内置支持.当要执行的任务被synchronized关键字保护的代码片段时,检查锁是否可用,然后获取锁,执行代码,释放锁.

在使用并发时,将域设置位private是非常重要的,否则,synchronized关键字就不能防止其他任务直接访问域,这样就会产生冲突.

所有对象都自动含有单一的锁(监视器).当在对象上调用任意的synchronized方法时,此对象都被枷锁,这时该对象上的其他synchronized方法只有等到前一个方法调用完毕
并释放了锁之后,其他任务才能调用f()和g().

针对每个类,也有一个锁,作为类Class对象的一部分,所以synchronized static 方法可以在类范围内防止对static数据的并发访问.

什么时候使用同步?

如果你正在写一个变量,他可能接下来被另一个线程读取,或者正在读取上一次已经被另一个线程写过的变量,那么你必须使用同步,并且读写线程都必须使用相同的监视器锁同步.

gi

