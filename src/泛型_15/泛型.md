
泛型实现了参数化类型的概念,使代码可以应用于多种类型.
泛型这个术语的意思是:适用于许多许多的类型.
其最初的目的是希望类或方法能够具备最广泛的表达能力.

# 简单泛型

促成泛型出现的原因-容器类

泛型的主要目的之一就是用来指定容器要持有什么类型的对象,而且由编译器来保证类型的正确性.

Java泛型的核心概念:告诉编译器想使用什么类型,然后编译器帮你处理一切细节.

## 一个元组类库

tuple 元组是将一组对象直接打包存储于其中一个单一的对象.数据传送对象,或者信使;允许读取其中元素,但是不允许向其中存放新对象.

## 一个堆栈类

## RandomList

# 泛型接口

Java泛型局限性:基本类型无法作为类型参数.

# 泛型方法

泛型方法使得该方法能够独立于类而产生变化.

应该尽量使用泛型方法.

对于一个static的方法而言,无法访问泛型类的了泛型参数,所以,如果static方法需要使用使用泛型能力,就必须使其成为泛型方法.

类型参数推断.使用泛型方法的时候,通常不必指明参数类型.

## 杠杆利用参数类型推断

## 可变参数与泛型方法

## 利用Generator的泛型方法

## 一个通用的Generator

## 简化元组的使用


# 匿名内部类

# 构造复杂模型

# 擦除的神秘之处


ArrayList<String> 和 ArrayList<Integer>很容易被看做是不同的类型.但是,实际上他们是相同的类型.

Class.getTypeParameters()返回表示有泛型声明的类型参数.

现实是:正在泛型代码内部,无法获得任何有关泛型参数类型的信息.

你可以知道诸如类型参数标识符和泛型类型边界这类的信息--你却无法知道用来创建某个特定实例的实际的类型参数.

Java的泛型是使用擦除来实现的,这意味着当你在使用泛型时,任何具体的类型信息都被擦除了,你唯一知道的就是你在使用一个对象.
因此List<String>和List<Integer>在运行事实上都是相同的类型.

想要调用某个泛型的方法,必须给定泛型类的边界.

边界<T extends HasF>声明T必须具有类型Hasf或者从HasF导出的类型.

我们说泛型类型参数将擦除到他的第一个边界(他可能有多个边界).

编译器实际上会吧类型参数替换为他的擦除.T擦除到了HasF,就像在声明用HasF替换了T一样.

## 迁移兼容性

程序中所有泛型类型部分都会被擦除,替换为他们的非泛型上界.

## 擦除的问题

# 擦除的补偿

可以通过传入类型标签对擦除进行补偿

## 创建类型实例

## 泛型数组

我们并不能声明T[] array = new T[size];但是我们可以创建一个对象数组,并对其转型.

成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组,然后对其转型.

不能忘记数组的运行时类型

传递类型标记,以便从擦除中恢复,使得我们可以创建需要的实际类型的数组.

# 边界

边界可以强制规定泛型可以应用的类型,但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法.

# 通配符

不能把一个涉及Apple的反省赋给一个涉及Fruit的泛型.
容器的类型和容器持有的类型不是一个概念.
想要在两个类型之前建立某种类型的上转型关系,这是?通配符所允许的.

```
List<? extends Fruit>
不能够向其添加对象
```

真正的问题在于谈论的是容器的类型,而不是容器持有的类型.


### 编译器有多聪明

### 逆变

超类型通配符.可以声明通配符是由某个特定类的任何基类来界定的,方法是指定<? super MyClass>,甚至使用类型参数
<? super T>.可以安全传递一个类型对象到泛型类型中.

// SuperTypeWildcards.java

### 无界通配符

无界通配符<?>看起来意味着"任何事物", 因此使用无界通配符好像等价于使用原生类型.

编译器很少关心使用的是原生类型还是<?>.在这种情况下,<?>可以认为是一种装饰,但是它仍旧很有价值.

实际上,他是在声明:"我是想用Java的泛型来编写这段代码,我这里并不是要使用原生类型,但是在当前这种情况下,泛型参数可以支持任何类型."

当在处理多个泛型参数时,有事允许一个参数可以是任何类型,同时其他参数确定某种特定类型的能力非常重要.


事实上,由于泛型参数将擦除到它的第一个边界,因此List<?>看起来等价于List<Object>,而List实际上也是List<Object>.

- List实际上表示:持有任何Object类型的原生List
- List<?>表示:具有某种特定类型的非原生List,只是我们不知道那种类型是什么.

# 问题

## 任何基本类型都不能作为类型参数

自动包装机制解决了一些问题,但并不是解决了所有问题.自动包装机制不能应用于基本类型数组.

## 实现参数化接口

一个类不能同时实现一个泛型接口的两种变体,由于擦除的原因,这两个变体会成为相同的接口.

## 转型和警告

使用带有泛型类型参数的转型或instanceof不会有任何效果.

T被擦除到它的第一个边界,默认情况下是Object,因此pop()实际上只是将Object转型为Object.

### 重载

由于擦除的原因,重载方法将产生相同的类型签名.

### 基类劫持了接口

# 自限定的类型

```
class SelfBounded<T extends SelfBounded<t>> {}
```

## 古怪的循环泛型(CRG)

本质:基类用导出类替代其参数.

这意味着泛型基类变成了一种其所有导出类的公共功能的模板.

## 自限定

自限定将采取额外的步骤,强制泛型当做其自己的边界参数来使用.

自限定所做的,就是要求在继承关系中,像这样使用:

```
class A extends SelfBounded<A>{}

static <T extends SelfBounded<T>> T f(T tag){}

```

这会强制要求将正在定义的类当做参数传递给基类.

有何意义?他可以保证类型参数必须与正在被定义的类相同.

自限定限制只能强制作用于继承关系.

## 参数协变

自限定类型的价值在于他们可以产生协变参数类型---方法参数类型会随子类而变化.

# 异常

# 混型

混型的价值之一是它们可以将特性和行为一致的应用于多个类之上.

## 与接口混合

## 使用装饰器模式

# 潜在类型机制

## 对缺乏潜在类型机制的补偿

### 反射

### 将一个方法应用于序列

### 当你并未碰巧拥有正确的接口时

### 用适配器仿真潜在类型机制

## 将函数对象用作策略

## 15.19 总结:转型真的如此之糟么?