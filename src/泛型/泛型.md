

## 边界

边界可以强制规定泛型可以应用的类型,但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法.

## 通配符

不能把一个涉及Apple的反省赋给一个涉及Fruit的泛型.
容器的类型和容器持有的类型不是一个概念.
想要在两个类型之前建立某种类型的上转型关系,这是?通配符所允许的.

```
List<? extends Fruit>
不能够向其添加对象
```


### 编译器有多聪明

### 逆变

超类型通配符.可以声明通配符是由某个特定类的任何基类来界定的,方法是指定<? super MyClass>,甚至使用类型参数
<? super T>.可以安全传递一个类型对象到泛型类型中.

// SuperTypeWildcards.java

### 无界通配符

无界通配符<?>看起来意味着"任何事物", 因此使用无界通配符好像等价于使用原生类型.

编译器很少关心使用的是原生类型还是<?>.在这种情况下,<?>可以认为是一种装饰,但是它仍旧很有价值.

实际上,他是在声明:"我是想用Java的泛型来编写这段代码,我这里并不是要使用原生类型,但是在当前这种情况下,泛型参数可以支持任何类型."

当在处理多个泛型参数时,有事允许一个参数可以是任何类型,同时其他参数确定某种特定类型的能力非常重要.


事实上,由于泛型参数将擦除到它的第一个边界,因此List<?>看起来等价于List<Object>,而List实际上也是List<Object>.

- List实际上表示:持有任何Object类型的原生List
- List<?>表示:具有某种特定类型的非原生List,只是我们不知道那种类型是什么.


## 问题

### 任何基本类型都不能作为类型参数

自动包装机制解决了一些问题,但并不是解决了所有问题.自动包装机制不能应用于基本类型数组.

### 实现参数化接口

一个类不能同时实现一个泛型接口的两种变体,由于擦除的原因,这两个变体会成为相同的接口.

### 转型和警告

使用带有泛型类型参数的转型或instanceof不会有任何效果.

T被擦除到它的第一个边界,默认情况下是Object,因此pop()实际上只是将Object转型为Object.


### 重载

由于擦除的原因,重载方法将产生相同的类型签名.

### 基类劫持了接口

## 自限定的类型

```
class SelfBounded<T extends SelfBounded<t>> {}
```

### 古怪的循环泛型(CRG)

本质:基类用导出类替代其参数.

### 自限定

自限定所做的,就是要求在集成关系中,像这样使用:

```
class A extends SelfBounded<A>{}

static <T extends SelfBounded<T>> T f(T tag){}

```

这会强制要求将正在定义的类当做参数传递给基类.

有何意义?他可以保证类型参数必须与正在被定义的类相同.

自限定限制只能强制作用于继承关系.

### 参数协变

自限定类型的价值在于他们可以产生协变参数类型---方法参数类型会随子类而变化.

