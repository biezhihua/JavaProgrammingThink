

## 定义任务

Thread.yield()的调用是对线程调度器(Java线程机制的一部分，可以将CPU从一个县城转移给另一个线程)

它在声明：我已经执行完声明周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机．


## 使用Executor 执行器

shutdown()防止新任务被提交给Executor

## 从任务中产生返回值

Runnable是执行工作的独立任务，但是没有返回值．如果希望获取返回值，那么应该使用Callable接口．必须使用ExecutorService.submit();

submit()方法会产生Future对象，isDone()查询Future是否完成.也可以不用isDone()进行检查就直接调用get()，这种情况下get()将阻塞方法直到获取
该结果，直至结果准备就绪

## 优先级

线程的优先级将该县城的重要性传递给调度器．优先级较低的线程仅仅是执行的频率较低．

绝大多数情况，所有线程都应该以默认优先级运行，试图操纵线程优先级通常是一种错误．

## 让步

## 后台 daemon 线程

是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分．
当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程．

必须在线程启动之前调用setDaemon()方法，才能把其设置为后台线程．

可以通过isDaemon()来确定线程是否是一个后台线程，如果是一个后台线程，呢么它创建的任何线程都被自动设置成后台线程．

后台线程在不执行finally子句的情况下就会终止其run()方法．因为，当一个非后台线程终止时，后台线程会＂突然＂终止.
因此,一旦main()退出,JVM就会立即关闭所有的后台线程.

## 编码的变体


## 捕获异常

# 共享受限资源

volatile是原子性的,即诸如赋值和返回值这样的简单操作在发生时没有中断的可能.

在java中,递增过程中任务可能会被线程机制挂起---也就是说,在java中,递增不是原子性操作.

