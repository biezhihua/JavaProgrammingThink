

## 定义任务

Thread.yield()的调用是对线程调度器(Java线程机制的一部分，可以将CPU从一个县城转移给另一个线程)

它在声明：我已经执行完声明周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机．


## 使用Executor 执行器

shutdown()防止新任务被提交给Executor

## 从任务中产生返回值

Runnable是执行工作的独立任务，但是没有返回值．如果希望获取返回值，那么应该使用Callable接口．必须使用ExecutorService.submit();

submit()方法会产生Future对象，isDone()查询Future是否完成.也可以不用isDone()进行检查就直接调用get()，这种情况下get()将阻塞方法直到获取
该结果，直至结果准备就绪

## 优先级

线程的优先级将该县城的重要性传递给调度器．优先级较低的线程仅仅是执行的频率较低．

绝大多数情况，所有线程都应该以默认优先级运行，试图操纵线程优先级通常是一种错误．

## 让步

## 后台 daemon 线程

是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分．
当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程．

必须在线程启动之前调用setDaemon()方法，才能把其设置为后台线程．

可以通过isDaemon()来确定线程是否是一个后台线程，如果是一个后台线程，呢么它创建的任何线程都被自动设置成后台线程．

后台线程在不执行finally子句的情况下就会终止其run()方法．因为，当一个非后台线程终止时，后台线程会＂突然＂终止.
因此,一旦main()退出,JVM就会立即关闭所有的后台线程.

## 编码的变体


## 捕获异常

# 共享受限资源

volatile是原子性的,即诸如赋值和返回值这样的简单操作在发生时没有中断的可能.

在java中,递增过程中任务可能会被线程机制挂起---也就是说,在java中,递增不是原子性操作.

## 解决共享资源竞争

你永远不知道一个线程何时在运行.

对于并发工作,需要某种方式来防止两个任务访问相同的资源,至少在关键阶段不能出现这种情况.

基本上所有的并发模式在解决线程冲突的问题时,都是采用序列化访问共享资源的方案.

这意味着在给定的时刻只允许一个任务访问共享资源.这通常是在代码前面加上一条锁语句,使得在一段时间内只有一个任务运行这段代码.

因为锁语句产生了一种互相排斥的效果,所以这种机制常常称为互斥量. mutex.

synchronized防止资源冲突提供了内置支持.当要执行的任务被synchronized关键字保护的代码片段时,检查锁是否可用,然后获取锁,执行代码,释放锁.

在使用并发时,将域设置位private是非常重要的,否则,synchronized关键字就不能防止其他任务直接访问域,这样就会产生冲突.

所有对象都自动含有单一的锁(监视器).当在对象上调用任意的synchronized方法时,此对象都被枷锁,这时该对象上的其他synchronized方法只有等到前一个方法调用完毕
并释放了锁之后,其他任务才能调用f()和g().

针对每个类,也有一个锁,作为类Class对象的一部分,所以synchronized static 方法可以在类范围内防止对static数据的并发访问.

什么时候使用同步?

如果你正在写一个变量,他可能接下来被另一个线程读取,或者正在读取上一次已经被另一个线程写过的变量,那么你必须使用同步,并且读写线程都必须使用相同的监视器锁同步.


### 显示的使用Lock对象

## 原子性与易变性

原子性可以应用于除long和double之外的所有基本类型智商的"简单操作".对于读取和写入除long和double之外的基本类型变量这样的操作,可以保证他们会被当做不可分的操作来操作内存.6tgc

原子性可以应用于除long和double之外的所有基本类型上的简单操作.


valatile关键是确保了可视性,如果产生了写操作,那么所有的读操作都可以看到这个修改.
 
什么属于原子操作?对域中的值做赋值和返回操作通常都是原子性的.

在java中 i++;  i+=2;不是原子性的.

基本上,如果一个域可能会被多个任务同时访问,或者这些任务至少有一个是写入任务,那么你就应该将这个域设置位volatile的.如果将一个域定义为
volatile,那么它会告诉编译器不要执行任何移除读取和写入操作的优化,这些操作的目的是用线程中的局部变量维护对这个域的精准同步.
实际上,读取和写入都是直接针对内存的,而却没有被缓存.但是,valatile并不能对递增不是原子性操作这一事实产生影响.

## 原子类

AtomicInteger AtomicLong AtomicReference

## 临界区

同步控制块

synchronized(syncObject) {
    
}

进入此段代码前,必须得到syncObject对象的锁,如果其他线程已经得到这个锁,那么就等到锁被释放后,才能进入临界区.

## 在其他对象上同步

## 线程本地存储

防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享. 线程本地存储是一种自动化机制,可以为使用相同变量的每个不同的线程创建不同的存储.
如果由5个线程都要使用变量x所表示的对象,那线程本地存储就会生成5个用于x的不同存储快.他们可以使得你将状态和线程关联起来.

创建和管理线程本地存储由ThreadLocal类来实现.

