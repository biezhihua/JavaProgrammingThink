

#前言

运行时类型信息使得你可以在程序运行时发现和使用类型信息.

如何识别运行时类型信息呢?
    1. 传统的RTTI,它假定我们在编译时已经知道了所有的类型
    2. 反射机制 
        
# 为什么需要RTTI

在Java中,所有的类型转换逗是在运行时进行正确性检查的.

RTTI的含义:运行时,识别一个对象的类型.


# Class对象

类型信息在运行时由称作"Class对象"的特殊对象表示的,它包含了与类有关的信息.

Class对象就是用来创建类的所有"常规"对象的.

Java使用Class对象来执行其RTTI(运行时,识别一个对象的类型). eg:类型转换

类是程序的一部分,每个类都有一个Class对象.

为了生成这个类的对象,JVM将使用被称为"类加载器"的子系统.

类加载器子系统实际上包含一条类加载器链,但是只有一个原生类加载器,它是JVM实现的一部分.原生类加载器加载的是可信类,包括JavaAPI,它们通常是从本地加载的.

所有的类都是在其第一次使用时,动态加载到JVM中的.当程序创建第一个对象的静态引用时,就会加载这个类.这证明构造器也是类的静态方法,因此new操作符创建的对象也会被当做对类的静态成员的引用.

Class.forName()是取得Class对象的引用的一种方法,它会导致类被加载.

无论何时,想在运行时使用类型信息,就必须首先获得恰当的Class对象的引用.
    1. Class.forName();
    2. obj.getClass()
    
## 类字面常量

类字面常量,获取Class对象的引用的另一种方式:Test.class

类字面常量的应用:
    1. 普通的类
    2. 接口
    3. 数组
    4. 基本数据类型
    5. 基本数据类型的包装类
    
使用".class"创建Class对象的引用时,不会自动的初始化该Class对象.为了使用类而做的准备实际包含三个步骤:
    1. 加载,由类加载器执行.查找字节码,并从字节码中创建一个对象.
    2. 链接,该阶段为静态域分配存储空间,解析这个类创建的对其他类的引用.
    3. 初始化,如果该类具有超类,则对其初始化,执行静态初始化器和静态初始化块.
    初始化被延迟到了静态时才执行.
    
## 泛化的Class引用

Class引用表示的就是它所指向的对象的确切类型.


下面是不正确的:
    Class<Number> clazz = int.class
它是错误的,因为Integer Class对象不是Number Class对象的子类.

为了创建一个Class引用,它被限定为某种类型,或者该类型的任何子类型,则需要这样做:
    Class<? extends Number> bounded = int.class
    
    
# 类型转换前先做检查

RTTI形式:
    1. 传统的类型转换
    2. 代表对象类型的Class对象
    3. 关键字instanceof,告诉我们是不是某个特定类型的实例,只可与其命名类型进行比较,而不能与Class对象做比较
    
    
## 使用类字面常量

## 动态的instanceof = isInstance()

# 注册工厂

# instanceof与Class

在查询类型信息时,以instanceof/isInstance()的形式,与直接比较Class对象有一个非常重要的差别.

instanceof和isInstance()生成的结果一致,equals()和==生成的结果一致

instanceof保持了类型的概念,它指的是"你是这个类么,或者你是这个类的派生类么"
==比较实际的Class对象,就没有考虑继承--它或者是这个确切的类型,或者不是

# 反射:运行时的类信息

人们想在运行时获取类的信息的另一个动机,在远程平台上创建和运行对象的能力,这称为远程方法调用(RMI).

Class类和java.lang.reflect类库一起对反射的概念进行了支持,该类库包括了Field/Method/Constructor类(每个类都实现了Memeber接口).
这样就可以使用Constructor创建新对象,用get()和set()方法读取和修改与Field对象关联的字段,用invoke()方法调用与Method对象关联的方法.

这样匿名对象的类信息就能正运行时被完全确定下来,而在编译时不需要知道任何事情.

## 类方法提取器


## 动态代理
    